I"≥<p>Jun Hur‚Äôs Blog Post 4 for PIC 16B!</p>

<h1 id="spectral-clustering">Spectral Clustering</h1>

<p>Here, we will write a tutorial on a simple version of the spectral clustering algorithm for clustering data points.</p>

<h2 id="notation">Notation</h2>
<p>In all the math below:</p>

<ul>
  <li>Boldface capital letters like <strong>A</strong> refer to matrices (2d arrays of numbers).</li>
  <li>Boldface lowercase letters like <strong>v</strong> refer to vectors (1d arrays of numbers).</li>
  <li><strong>AB</strong> refers to a matrix-matrix product (A@B). <strong>Av</strong> refers to a matrix-vector product (A@v)</li>
</ul>

<h2 id="motivation">Motivation</h2>

<p>Consider the following plot:</p>

<p><img src="/images/blog_4_code_0.JPG" alt="_config.yml" />
<img src="/images/blog_4_moti_0.JPG" alt="_config.yml" /></p>

<p>They are clearly divided by two <em>groups</em>, so such spectral clustering is not needed.</p>

<p><em>Clustering</em> refers to the task of separating this data set into the two natural <strong>‚Äúblobs.‚Äù</strong> K-means is a very common way to achieve this task, which has good performance on circular-ish blobs like these:</p>

<p><img src="/images/blog_4_code_1.JPG" alt="_config.yml" />
<img src="/images/blog_4_moti_1.JPG" alt="_config.yml" /></p>

<p>What about somewhat more complex dataset?</p>

<p><img src="/images/blog_4_code_2.JPG" alt="_config.yml" />
<img src="/images/blog_4_moti_2.JPG" alt="_config.yml" /></p>

<p><img src="/images/blog_4_code_3.JPG" alt="_config.yml" />
<img src="/images/blog_4_moti_3.JPG" alt="_config.yml" /></p>

<p>So, the clustering is not as good as before, is it?</p>

<h2 id="part-a--similarity-matrix--a">Part A : <em>Similarity Matrix</em>  <strong>A</strong></h2>

<p>Here, <strong>A</strong> will be a matrix (2d) with shape <code class="language-plaintext highlighter-rouge">(n,n)</code>, where each entry <code class="language-plaintext highlighter-rouge">A[i,j]</code> is equal to 1 if <code class="language-plaintext highlighter-rouge">X[i]</code> (the coordinates of data point <code class="language-plaintext highlighter-rouge">i</code>) is within distance <code class="language-plaintext highlighter-rouge">epsilon</code> of <code class="language-plaintext highlighter-rouge">X[j]</code>, and <code class="language-plaintext highlighter-rouge">0</code> otherwise</p>

<p>For this part, we will use <code class="language-plaintext highlighter-rouge">epsilon = 0.4</code></p>

<p>First, let‚Äôs set up the basics:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">.</span><span class="n">make_moons</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>X</strong> <code class="language-plaintext highlighter-rouge">(n x 2)</code> is a matrix representing <code class="language-plaintext highlighter-rouge">n</code> data points.</p>

<p><img src="/images/blog_4_A_0.JPG" alt="_config.yml" /></p>

<p>To create such matrix <strong>A</strong>, we need to use <code class="language-plaintext highlighter-rouge">sklearn.metrics.pairwise</code> from <code class="language-plaintext highlighter-rouge">pairwise_distances</code>. The doc for this is <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.pairwise_distances.html"> here </a>.</p>

<p>First, we fill in the entries of <strong>A</strong> with <code class="language-plaintext highlighter-rouge">True</code> or <code class="language-plaintext highlighter-rouge">False</code>, depending on whether <code class="language-plaintext highlighter-rouge">X</code> is within distance of epsilon of <code class="language-plaintext highlighter-rouge">X[j]</code>. Then, we convert the entry values to <code class="language-plaintext highlighter-rouge">0</code> or <code class="language-plaintext highlighter-rouge">1</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="kn">import</span> <span class="n">pairwise_distances</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">)</span>
<span class="n">A</span>
</code></pre></div></div>

<p><img src="/images/blog_4_A_1.JPG" alt="_config.yml" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">A</span>
</code></pre></div></div>
<p><img src="/images/blog_4_A_2.JPG" alt="_config.yml" /></p>

<p>Finally, we set the entries of <strong>A</strong> to 0, that is, <code class="language-plaintext highlighter-rouge">A[i,i] = 0</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">np</span><span class="p">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">A</span>
</code></pre></div></div>
<p><img src="/images/blog_4_A_3.JPG" alt="_config.yml" /></p>

<h2 id="part-b1--the-cut-term">Part B.1 : The Cut Term</h2>

<p>We will call \(d_i = \sum_{j = 1}^n a_{ij}\) the <em>degree of i</em>, so the <code class="language-plaintext highlighter-rouge">ith row-sum of A</code>.</p>

<p>Also, let \(C_0\) and \(C_1\) be two clusters of the data points, and each data point is in either \(C_0\) or \(C_1\).</p>

<p>Now, the binary norm cut object of a matrix <strong>A</strong> is:</p>

\[N_{\mathbf{A}}(C_0, C_1)\equiv \mathbf{cut}(C_0, C_1)\left(\frac{1}{\mathbf{vol}(C_0)} + \frac{1}{\mathbf{vol}(C_1)}\right)\;.\]

<p>Where</p>

<ul>
  <li>\(\mathbf{cut}(C_0, C_1) \equiv \sum_{i \in C_0, j \in C_1} a_{ij}\)  is the cut of the clusters \(C_0\) and \(C_1\).</li>
  <li>\(\mathbf{vol}(C_0) \equiv \sum_{i \in C_0}d_i\) where \(d_i = \sum_{j = 1}^n a_{ij}\) is the <em>degree</em> of row i. Thus, the <em>volume</em> of cluster is a measure of the size of the cluster.</li>
</ul>

<p>First, the cut term \(\mathbf{cut}(C_0, C_1)\) is the number of nonzero entries in <strong>A</strong> that relate points in cluster \(C_0\) to points in cluster \(C_1\).</p>

<p>A function <code class="language-plaintext highlighter-rouge">cut(A,y)</code> will compute the cut term. Here, we will sum up the entries <code class="language-plaintext highlighter-rouge">A[i,j]</code> for each pair of points <code class="language-plaintext highlighter-rouge">(i,j)</code> in different clusters.</p>
:ET